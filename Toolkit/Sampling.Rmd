---
title: "Sampling Resources"
output: html_notebook
---

# 1. Functions

## Stratified Random Sample Across 3 Factors of Interest

* Expected Output: a sample dataset from an original dataset that includes random samples of an specified n for all groups defined by the combination of 3 factors in your original dataset

* Input: 
  * The desired number of samples per group (my.n)
  * The original dataset (my.data)
  * The names of the three factor columns in the dataset (my.factor1, my.factor2, my.factor3) as character strings.
  
* Potential adaptations: 
  * The sample sizes for each subgroup might be specified within the formula

```{r}

f.sample.3f <- function(my.n, my.data, my.factor1, my.factor2, my.factor3){
  
  # Input validation: Ensure factor names are passed as character strings.
  if (!is.character(my.factor1) || !is.character(my.factor2) || !is.character(my.factor3)) {
    stop("The factors have to be character chains, with names within quotation marks.")
  }
  
  # Initialize an empty list to store the sampled subsets from each stratum.
  results <- list() 
  
  # Initialize a counter for indexing elements in the 'results' list.
  k <- 1 
  
  # Iterate through each unique level of the first factor.
  for (i in unique(my.data[[my.factor1]])){
    # Within each level of the first factor, iterate through unique levels of the second factor.
    for(j in unique(my.data[[my.factor2]])){
      # Within each combination of the first two factors, iterate through unique levels of the third factor.
      for (q in unique (my.data[[my.factor3]])){
        
        # Filter the original dataframe to get the subset of data
        current.subset <- my.data[my.data[[my.factor1]] == i & 
                                  my.data[[my.factor2]] == j & 
                                  my.data[[my.factor3]] == q, ]
          
        # Get the number of rows (cases) in the current subset.
        current_rows <- nrow(current.subset)
          
        # Sampling logic based on the size of the current group:
        if(current_rows == 0){
          # If the group has no cases, issue an informative warning and go to the next loop
          warning(paste0("The group (", my.factor1, "=", i, ", ", my.factor2, "=", j, ", ", 
                         my.factor3, "=", q, ") has no cases."))
          next 
        } else if (current_rows >= my.n){
          # If the group has  equal to or greater cases than the desired n, we take a random sample:
          current.subset <- current.subset[sample(current_rows, my.n), ]
        } else if (current_rows < my.n) {
          # If the group has fewer cases than desired n, include all available cases, with a warning.
          warning(paste0("The group (", my.factor1, "=", i, ", ", my.factor2, "=", j, ", ", 
                         my.factor3, "=", q, ") has less cases than the expected n. All available cases will be included."))
        }
          
        # Add the processed subset (either sampled or full) to our list of results.
        results[[k]] <- current.subset
        # Increment the counter for the next element in the list.
        k <- k+1
          
      } # End of the third factor (q) loop
    } # End of the second factor (j) loop
  } # End of the first factor (i) loop

  # Final check: If the 'results' list is empty after all loops,
  # it means no groups could be sampled (e.g., all were empty).
  # In this case, return an empty dataframe.
  if (length(results) == 0) {
    message("No groups met the sampling criteria or all groups were empty. Returning an empty data frame.")
    return(data.frame())
  }
  
  # Combine all dataframes from the 'results' list into a single dataframe.
  sample.df <- do.call(rbind, results)
  
  # Return the final sampled dataframe.
  return(sample.df)
}

```


* Example of usage: 

```{r}
data.complaints <- f.sample.3f(
  my.n = 100,             # Desired number of cases per stratum
  my.data = data,         # Your input dataframe
  my.factor1 = "method",  # Column name for the first factor (as a character string)
  my.factor2 = "reason.grouped",  # Column name for the second factor (as a character string)
  my.factor3 = "country"  # Column name for the third factor (as a character string)
)
```



# 2. Examples of Other Sampling Resources

## Random Samples in Specified Subgroups

This exemplifies how to perform random samples in two subgroups, from the project "Predicting Customers Detractors (2)". 

```{r}

# Specify the sample sizes for both samples
sample.n <- 200

# Sample 1: Cases of chat attending incorrect items
subset_chat_incorrect<- data[data$reason == "incorrect_item" & data$method == "chat", ]
subset1.rows <- nrow(subset_chat_incorrect)
sample_chat_incorrect <- subset_chat_incorrect[sample(1:subset1.rows, sample.n), ]
sample_chat_incorrect$condition <- "chat_incorrect_item"

#Sample 2: Cases of chat attending other issues
subset_chat_other <- data[!(data$reason == "incorrect_item") & data$method == "chat", ]
subset2.rows <- nrow(subset_chat_other)
sample_chat_other <- subset_chat_other[sample(1:subset2.rows, sample.n), ]
sample_chat_other$condition <- "chat_other_issues"

#Bind together the two samples in a dataset
data.ch.i <- bind_rows(sample_chat_incorrect, sample_chat_other)
data.ch.i$condition <- factor(data.ch.i$condition)
#Check the final sample
summary(data.ch.i)

```

```

